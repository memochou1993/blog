---
title: 《精通 Go 程式設計》學習筆記（二）：程式結構
permalink: 《精通-Go-程式設計》學習筆記（二）：程式結構
date: 2020-03-24 12:02:28
tags: ["程式設計", "Go", "《精通 Go 程式設計》學習筆記"]
categories: ["程式設計", "Go", "《精通 Go 程式設計》學習筆記"]
---

## 前言

本文為《精通 Go 程式設計》一書的學習筆記。

## 名稱

Go 有以下 25 個保留字：

```TABLE
break      default       func     interface   select
case       defer         go       map         struct
chan       else          goto     package     switch
const      fallthrough   if       range       type
continue   for           import   return      var
```

另有 30 多個預先宣告的名稱：

```TABLE
常數: true false iota nil

型別: int int8 int16 int32 int64
      uint uint8 uint16 uint32 uint64 uintptr
      float32 float64 complex128 complex64
      bool byte rune string error

函式: make len cap new append copy close delete
      complex real imag
      panic recover
```

如果一個實體是在函式內宣告，它對該函式而言是區域（local）的。名稱的第一個字母決定它的可見度是否跨越套件邊界。如果名稱以大寫字母開頭，它是匯出（exported）的。名稱長度無限制，但 Go 程式的傳統傾向短名稱，組合字彙成名稱時使用 camel case，而縮寫術語會維持原來的大小寫。

## 宣告

下面的程式宣告一個常數和幾個變數：

```GO
package main

import (
	"fmt"
)

const boilingF = 212.0

func main() {
	var f = boilingF
	var c = (f - 32) * 5 / 9
	fmt.Printf("boiling point = %g°F or %g°C\n", f, c)
}
```

`boilingF` 常數是套件層級的宣告，而變數 `f` 與 `c` 是 main 函式的區域宣告。

下面的 fToC 函式封裝溫度轉換邏輯：

```GO
package main

import "fmt"

func main() {
	const freezingF, boilingF = 32.0, 212.0
	fmt.Printf("%g°F = %g°C\n", freezingF, fToC(freezingF)) // "32°F = 0°C"
	fmt.Printf("%g°F = %g°C\n", boilingF, fToC(boilingF))   // "212°F = 100°C"
}

func fToC(f float64) float64 {
	return (f - 32) * 5 / 9
}
```

## 變數

每個宣告都以通用形式進行：

```GO
var name type = expression
```

如果省略運算式，則初始值是該型別的零值，也就是數字的 `0`、布林的 `false`、字串的 `""`，以及介面與參考型別的 `nil`。

### 短變數宣告

短變數宣告的形式為：

```GO
name := expression
```

而 `:=` 用於宣告， `=` 用於指派：

```GO
i, j = j, i // 交換 i 與 j 的值
```

短變數宣告可用於呼叫 `os.Open()` 等回傳兩個或以上值的函式：

```GO
f, err := os.Open(name)
```

短變數宣告至少宣告一個新變數：

```GO
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

### 指標

變數是值的儲存體。指標是變數的位址，因此指標儲存值的位置。如果變數是以 `var x int` 宣告，則 `&x` 這個運算式（`x` 的位址）會產生一個整數變數的指標，也就是型別為 `*int` 的值，念法為 pointer to int。如果此值稱為 `p`，則可以說「`p` 指向 `x`」。`p` 指向的變數寫做 `*p`，`*p` 產生該變數的值，也就是一個 int。

```GO
package main

import "fmt"

func main() {
	x := 1
	p := &x
	fmt.Println(*p) // 1
	*p = 2
	fmt.Println(x) // 2
}
```

指標可以比較，兩個指標只在指向同一個變數或均為 `nil` 時才會相等。

```GO
package main

import "fmt"

func main() {
	var x, y int
	fmt.Println(&x == &x, &x == &y, &x == nil) // true false false
}
```

指標是 `flag` 套件的關鍵，以下範例 `flag.Bool()` 和 `flag.Srting()` 取用三個參數：`flag` 的名稱、變數的預設值和使用者提供無效的參數或 `-h` 與 `-help` 時輸出的訊息。執行程式時，它必須在使用 flag 之前呼叫 `flag.Parse()` 以將 flag 變數預設值更新。

```GO
package main

import (
	"flag"
	"fmt"
	"strings"
)

var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

func main() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}
```

執行：

```GO
go run main.go -s / a bc def
a/bc/def
```

### new 函式

`new(T)` 運算式建構一個 T 型別的不具名變數，以 T 的零值初始化，並回傳 *T 型別的位址值。

```GO
package main

import (
	"fmt"
)

func main() {
	p := new(int)
	fmt.Println(*p) // 0
	*p = 2
	fmt.Println(*p) // 2
}
```

使用 `new()` 建構的變數與一般區域變數沒有不同。`new()` 函式相對較少使用，因為大部分不具名變數的型別為 struct，而 struct 的實字語法更有彈性。

### 變數的生命週期

每次執行宣告陳述時就會建構新的實例，變數保持存活直到它不再可觸及為止，此時它的儲存體可能被回收。函式參數與結果也是區域變數：它們在函式被呼叫時建構。

垃圾回收機制的基本概念是，每個套件層級變數，以及每個函式中的區域變數，均為回收對象的根源路徑，依循指標與其他類型的參考最終會指向該變數。如果不存在這樣的路徑，變數就變成不可觸及的，所以它不再能夠影響其餘的運算。

垃圾回收對寫出正確程式有很大的幫助，在生命期長的物件，特別是全域變數中保存不必要的短生命期物件指標會阻止垃圾回收取回記憶體。

## 指派

最簡單的指派形式是變數在 `=` 的左邊，而運算式在右邊。

```GO
	x = 1                       // 具名變數
	*p = true                   // 間接變數
	person.name = "bob"         // struct 欄位
	count[x] = count[x] * scale // 陣列、切片或 map 元素
```

每個數學與二元運算子有相對應的指派運算子，例如可寫成：

```GO
count[x] *= scale
```

數值變數也可以使用 `++` 與 `--` 陳述遞增或遞減：

```GO
v := 1
v++ // 等同 v = v + 1
v-- // 等同 v = v - 1
```

### 資料組指派

資料組指派，可一次指派多個變數。舉例來說，交換兩個變數的值：

```GO
x, y = y, x
a[i], a[j] = a[j], a[i]
```

以下範例為計算兩個整數的最大公因數：

```GO
package main

import (
	"fmt"
)

func main() {
	fmt.Println(gcd(35, 17))
}

func gcd(x, y int) int {
	for y != 0 {
		x, y = y, x%y
	}

	return x
}
```

資料組指派可以讓一系列指派更為精簡：

```GO
i, j, k = 2, 3, 5
```

但若運算式較為複雜時應避免使用資料組；一系列獨立的陳述比較容易閱讀。

通常函式使用額外的結果來指示某種錯誤。有三種運算子有時也會有這種行為，如 `map` 查詢、型別判斷，或 `channel` 接收，出現在預期有兩個結果的指派中，每個都會產生一個額外的布林結果。

```GO
v, ok = m[key] // map 查詢
v, ok = x.(T)  // 型別判斷
v, ok = <-ch   // channel 接收
```

如同變數宣告，我們可以指派不要的值給空識別符號：

```GO
_, err = io.Copy(dst, src) // 拋棄位元組計數
_, ok = x.(T)              // 檢查型別但拋棄結果
```

### 可指派性

指派僅於值對變數的型別是可指派時才合法，規則很簡單：型別必須一致，而 nil 可以指派給任何介面或參考型別的變數。

## 型別宣告

`type` 宣告定義其底層型別與現有型別相同的新具名型別。具名型別提供分離底層型別不相容差異的方法以讓它們不會意外搞混。

```GO
type name underlying-type
```

以下範例將不同溫度單位放在不同型別中：

```GO
package main

type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit {
	return Fahrenheit(c*9/5 + 32)
}

func FToC(f Fahrenheit) Celsius {
	return Celsius((f - 32) * 5 / 9)
}
```

這裡定義 Celsius 與 Fahrenheit 兩個型別給兩種溫度單位。雖然兩者的底層型別都是 float64，但它們不是相同的型別，因此不能進行比較或數學運算式的並用。從 float64 轉換時，必須使用 Celsius(t) 或 Fahrenheit(t) 等明確的型別轉換，Celsius(t) 與 Fahrenheit(t) 是型別轉換而非函式呼叫。

每個型別 T 都有相對應的轉換操作 T(x) 可將 x 值轉換成 T 型別。

具名型別的底層型別決定它的結構與表示，還有所支援的操作，如果直接使用底層型別則相同。這表示 Celsius 與 Fahrenheit 的數學運算子與在 float64 上相同。

```GO
fmt.Printf("%g\n", BoilingC-FreezingC)
```

具名型別可提供寫程式的便利，如果它能夠幫助避免反覆寫出複雜的型別轉換。

具名型別也可定義型別值的新行為，它們被稱為方法。

以下程式碼宣告 Celsius 型別下回傳 c 數值加上 °C 的 `String()` 方法，其參數 c 出現在函式名稱之前：

```GO
func (c Celsius) String() string {
	return fmt.Sprintf("%g°C", c)
}
```

## 套件與檔案

Go 的套件的作用如同其他語言的函式庫或模組，支援模組化、封裝、個別編譯，與重複使用。套件的原始碼放在一或多個 `.go` 檔案中，通常位於匯入路徑結尾的目錄下。

套件做為其宣告的獨立命名空間。以 `image` 套件為例，`Decode` 識別字指向的函式與 `unicode/utf16` 套件中同名的函式不同。

### 匯入

在 Go 程式中，套件是以稱為匯入路徑的獨特字串來識別。它們出現在 `import` 宣告的字串後。除了匯入路徑之外，每個套件有個套件名稱，出現在 `package` 宣告的短名稱後。

### 套件初始化

利用 `init` 程序機制是設置初始值的最簡單的方式，可帶有任意數量宣告如下的函式：

```GO
func init() {
	// ...
}
```

宣告將名稱與函式或變數等程式實體產生關聯。宣告的範圍（scope）是所宣告名稱指向該宣告的原始碼部分。

在每個檔案中，`init()` 函式會在程式啟動時自動以宣告的順序執行。

## 範圍

語句（syntactic）區塊是函式內容或迴圈等包圍在括弧內的一連串陳述。語句區塊中的名稱宣告在區塊外不可見。區塊包圍它的宣告並決定它們的範圍。我們可以在這種區塊中引入程式中其他沒有被括弧直接包圍的宣告群組；稱其為詞彙（lexical）區塊。詞彙區塊有稱為全通（universe）區塊的全程式範圍區塊；有套件的詞彙區塊；檔案的詞彙區塊；控制流程的詞彙區塊；以及每個語句區塊的詞彙區塊。

## 參考資料

- Alan A. A. Donovan, Brian W. Kernighan。精通 Go 程式設計。台北市：碁峯資訊。
