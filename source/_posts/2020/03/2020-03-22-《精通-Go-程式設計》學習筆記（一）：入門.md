---
title: 《精通 Go 程式設計》學習筆記（一）：入門
permalink: 《精通-Go-程式設計》學習筆記（一）：入門
date: 2020-03-22 23:02:58
tags: ["程式設計", "Go", "《精通 Go 程式設計》學習筆記"]
categories: ["程式設計", "Go", "《精通 Go 程式設計》學習筆記"]
---

## 前言

本文為《精通 Go 程式設計》一書的學習筆記。

## Hello, World

「Hello, World」出現在 1978 年出版的 The C Programming Language 一書的開頭。C 對 Go 有直接的影響。

```GO
package main

import "fmt"

func main() {
	fmt.Println("Hello", "世界")
}
```

Go 是編譯語言，Go 工具組將原始碼與相關內容轉換成電腦原生機械碼指令。這些工具都是透過具有子命令並稱為 `go` 的單一命令操作。最簡單的命令是 `run`，它將一或多個副檔名為 `.go` 的原始檔案編譯並連結函式庫，然後執行所產生的可執行檔案。

```BASH
go run main.go
```

Go 預設就是處理 Unicode，因此它可以處理各種語言文字。

Go 程式以套件（package）組織，它類似其他語言的函式庫或模組。套件由定義此套件功能的一個目錄下的一或多個 `.go` 原始檔案組成。每個原始檔的開頭是 `package` 宣告，表示檔案所屬的套件，後面接著是一列它要匯入的其他套件，然後是此檔案所儲存的程式的宣告。

`main` 套件比較特別，它定義獨立的可執行程式而非函式庫。`main` 套件中的 `function main` 也比較特殊——它是程式執行的起點。

Go 不需要在陳述或宣告後面加上分號，除非兩個或以上放在同一行。實際上，特定單元後面的換行會被轉換成分號，因此換行對 Go 程式碼解析有影響。

Go 對程式碼格式有很高的要求，`gofmt` 工具會將程式碼重新排列成標準格式，許多文字編輯器可以設定在每次存檔時執行 `gofmt`，因此可以讓你的程式一直保持正確的格式。

## 命令列參數

大部分的程式處理一些輸入以產生一些輸出；這大概就是電腦運算的定義。

`os` 套件以平台無關的方式提供處理作業系統的函式與其他值。命令列參數在程式中可透過稱為 `Args` 的變數取得，它是 `os` 套件的一部分；因此在 `os` 套件之外，它的全名是 `os.Args`。

以下是 Unix 的 echo 命令的實作，它以單行輸出它的命令列參數。

```GO
package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep string

	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}

	fmt.Println(os.Args)
}
```

`for` 迴圈是 Go 唯一的迴圈陳述，它具有多種形式，其中一個如下：

```GO
for initialization; condition; post {
	//
}
```

如果沒有 initialization 與 post，分號可以省略：

```GO
for condition {
	//
}
```

如果在各種形式完全省略條件，則此迴圈為無限，必須以 `break` 或 `return` 結束。

```GO
for {
	//
}
```

以下以第二個 echo 來示範：

```GO
package main

import (
	"fmt"
	"os"
)

func main() {
	s, sep := "", ""

	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}

	fmt.Println(s)
}
```

空識別符（`_`）可用於語法需要但程式邏輯不需要變數名稱的情況，例如在只需要元素值時使用來拋棄不需要的迴圈索引。

字串變數宣告有幾種方式；它們都相等：

```GO
s := ""
var s string
var s = ""
var s string = ""
```

實務上，一般應該使用前兩種形式，明確的初始化已表明初始值很重要。

如果牽涉的資料量很大，其成本可能會很高。更簡單與有效率的解決方案是用 `strings` 套件的 `Join()` 函式：

```GO
package main

import (
	"fmt"
	"os"
	"strings"
)

func main() {
	fmt.Println(strings.Join(os.Args[1:], " "))
}
```

## 找出重複行

以下展示稱為 dup 的程式的三種變化；它受到 Unix 的 uniq 命令啟發，用來找尋相鄰的重複行。

dup 的第一個版本輸出標準輸入中出現超過一次的行，前面加上次數。

```GO
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	input := bufio.NewScanner(os.Stdin)

	for input.Scan() {
		counts[input.Text()]++
	}

	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
```

`map` 保存一組鍵值對並提供儲存、讀取、檢測元素的操作。再來是 `bufio` 套件，它幫助輸出入的效率與方便性。它的最重要功能之一是讀取輸入並將其拆分成多行的 `Scanner` 型別；它是處理多行輸入最簡單的方式。

scanner 從程式的標準輸入讀取。每次呼叫 `input.Scan()` 讀取下一行並移除後面的換行字元；其結果可透過呼叫 `input.Text()` 取得。`Scan()` 函式在有下一行的時候回傳 `true`，在沒有更多的輸入時回傳 `false`。

下一個版本的 dup 可從標準輸入讀取，或以 `os.Open` 開啟處理一系列檔案：

```GO
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	files := os.Args[1:]

	if len(files) == 0 {
		countLines(os.Stdin, counts)
	} else {
		for _, arg := range files {
			f, err := os.Open(arg)

			if err != nil {
				fmt.Fprintf(os.Stderr, "dup: %v\n", err)
				continue
			}

			countLines(f, counts)
			f.Close()
		}

		for line, n := range counts {
			if n > 1 {
				fmt.Printf("%d\t%s\n", n, line)
			}
		}
	}
}

func countLines(f *os.File, counts map[string]int) {
	input := bufio.NewScanner(f)

	for input.Scan() {
		counts[input.Text()]++
	}
}
```

`os.Open()` 函式回傳兩個值，第一個是開啟的檔案，用於後續 scanner 的讀取；第二個是內建的 `error` 型別。

以下的 dup 版本是一次讀取完整的輸入到記憶體中，一次將行全部拆開，然後處理這些行。它使用 `ReadFile()` 函式讀取檔案的全部內容，與 `strings.Split()` 拆解字串到 slice 中。

```GO
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

func main() {
	counts := make(map[string]int)

	for _, filename := range os.Args[1:] {
		data, err := ioutil.ReadFile(filename)

		if err != nil {
			fmt.Fprintf(os.Stderr, "dup: %v\n", err)
			continue
		}

		for _, line := range strings.Split(string(data), "\n") {
			counts[line]++
		}
	}

	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
```

`ReadFile()` 回傳位元組的 slice，必須轉換成 string 以便由 `strings.Split()` 拆開。

## 動態 GIF

以下示範使用 Go 的標準圖形套件，來建構一系列的點陣圖然後組成一個動態 GIF 圖。

```GO
package main

import (
	"image"
	"image/color"
	"image/gif"
	"io"
	"math"
	"math/rand"
	"os"
)

var palette = []color.Color{color.White, color.Black}

const (
	whiteIndex = 0
	blackIndex = 1
)

func main() {
	lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
	const (
		cycles  = 5     // x 振盪旋轉數
		res     = 0.001 // 角解析度
		size    = 100   // 畫布大小
		nframes = 64    // 幀數
		delay   = 8     // 以 10ms 為單位的幀間隔
	)

	freq := rand.Float64() * 3.0 // y 振盪相對頻率
	anim := gif.GIF{LoopCount: nframes}
	phase := 0.0 // 相位差

	for i := 0; i < nframes; i++ {
		rect := image.Rect(0, 0, 2*size+1, 2*size+1)
		img := image.NewPaletted(rect, palette)

		for t := 0.0; t < cycles*2*math.Pi; t += res {
			x := math.Sin(t)
			y := math.Sin(t*freq + phase)
			img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)
		}

		phase += 0.1
		anim.Delay = append(anim.Delay, delay)
		anim.Image = append(anim.Image, img)
	}

	gif.EncodeAll(out, &anim)
}
```

`const` 宣告賦予常數名稱，也就是在編譯期固定的值。常數值必須是數字、字串或布林。

lissajous 函式有兩個套疊迴圈。外面的迴圈執行 64 輪，每一輪產生一幀。它建構出新的 201×201 大小黑白兩色圖形。所有像素一開始設為調色盤的零值（調色盤的第零個顏色），也就是我們所設定的白色。外層迴圈在每一輪設定一些像素為黑色以產生新的圖形，其結果使用內建的 `append` 函式疊加到 `anim` 的幀列中，間隔為 80ms。最後幀列與間隔被編成 GIF 格式寫入輸出串流 `out` 中。`out` 的型別是 `io.Writer`，它讓我們可以輸出到各種目標上。

內迴圈跑二維振盪。x 振盪只是個正弦函式，而 y 振盪也是個正弦波，但其頻率與 x 振盪是介於 0 到 3 的隨機關係，且與 x 振盪的相位關係初始為零且隨著幀遞增。迴圈持續執行直到 x 振盪完成五個循環。它在每個步驟中呼叫 `SetColorIndex` 以設定相對應像素為調色盤位置一的黑色。

以下命令產生動態 GIF：

```BASH
go build main.go && ./main > out.gif
```

## 抓取 URL 內容

Go 提供一群集合於 `net` 之下的套件讓發送和接收網路資料、低階網路連線、設置伺服器變得容易。以下稱為 fetch 的簡單程式能夠抓取指定 URL 的內容並原封不動的輸出。

```GO
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

func main() {
	for _, url := range os.Args[1:] {
		resp, err := http.Get(url)
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
			os.Exit(1)
		}

		b, err := ioutil.ReadAll(resp.Body)
		resp.Body.Close()

		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: reading %s %v\n", url, err)
			os.Exit(1)
		}

		fmt.Printf("%s", b)
	}
}
```

此程式使用 `net/http` 和 `io/ioutil` 兩個套件的函式。`http.Get()` 函式發出 HTTP 請求，從 `resp` 這個 struct 回傳結果。接下來 `ioutil.ReadAll()` 讀取整個回應；其結果儲存於 `b`。`Body` 串流關閉以避免資源洩漏。而 `Printf` 將回應寫到標準輸出。

```GO
go run main.go http://gopl.io
```

如果 HTTP 請求失敗， fetch 會回報失敗：

```GO
go run main.go http://bad.gopl.io
fetch: Get http://bad.gopl.io: dial tcp: lookup bad.gopl.io: no such host
exit status 1
```

## 並行抓取 URL 內容

## 網頁伺服器

Go 的函式庫讓撰寫網頁伺服器以回應 fetch 之類的用戶端請求變得很容易。以下示範回傳用於存取伺服器的 URL 路徑的迷你伺服器。

```GO
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", handler)
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}
```

以下的版本做出同樣的回應，但還有請求的總數：

```GO
package main

import (
	"fmt"
	"log"
	"net/http"
	"sync"
)

var (
	mu    sync.Mutex
	count int
)

func main() {
	http.HandleFunc("/", handler)
	http.HandleFunc("/count", counter)
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	count++
	mu.Unlock()
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}

func counter(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	fmt.Fprintf(w, "Count %d\n", count)
	mu.Unlock()
}
```

伺服器在幕後為每個請求從獨立的 `goroutine` 上執行處理程序，因此它可以同時處理多個請求。然而，若有兩個並行的請求同時嘗試更新 count，它或許無法正確地遞增。程式或許會有競爭條件（race condition）的嚴重錯誤。為避免此錯誤，我們必須確保每次最多只有一個 `goroutine` 存取該變數，這就是 `mu.Lock()` 與 `mu.Unlock()` 包圍 count 的目的。

```GO
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", handler)
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "%s %s %s\n", r.Method, r.URL, r.Proto)

	for k, v := range r.Header {
		fmt.Fprintf(w, "Header[%q] = %q\n", k, v)
	}

	fmt.Fprintf(w, "Host = %q\n", r.Host)
	fmt.Fprintf(w, "RemoteAddr = %q\n", r.Host)

	if err := r.ParseForm(); err != nil {
		log.Print(err)
	}

	for k, v := range r.Form {
		fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
	}
}
```

Go 允許像是區域變數宣告等簡單的陳述放在 `if` 條件之前，合併的陳述較短且減小 `err` 變數的範圍，這樣是比較好的做法。

這些程式中，看到三種不同的型別用於輸出串流。fetch 程式複製 HTTP 回應資料給 `os.Stdout`；fetchall 程式以 `ioutil.Discard` 拋掉回應（只計算長度）；而網頁伺服器則使用 `fmt.Fprintf` 寫入代表網頁瀏覽器的 `http.ResponseWriter`。雖然這三種型別在執行細節上有所不同，但它們都滿足一個共同的介面，讓它們可以用於任何需要輸出串流的地方。此介面稱為 `io.Writer`。

以下範例結合網頁伺服器與 lissajous 函式，以讓動態 GIF 輸出到 HTTP 用戶端而非標準輸出。

```GO
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
	lissajous(w)
})
```

`HandleFunc()` 函式的第二個參數是「函式實字」，也就是定義於使用位置的不具名函式。

## 參考資料

- Alan A. A. Donovan, Brian W. Kernighan。白話區塊鏈。台北市：碁峯資訊。
