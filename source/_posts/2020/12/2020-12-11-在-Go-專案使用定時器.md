---
title: 在 Go 專案使用定時器
date: 2020-12-11 00:35:03
tags: ["程式設計", "Go"]
categories: ["程式設計", "Go", "其他"]
---

## 做法

### 方法一

使用無窮迴圈搭配 `time.Sleep()` 方法，可以達到每隔一段時間執行程式的效果。如果期望的週期是 2 秒，程式的執行時間是 n 秒，則一次的循環最短為 2 秒，最長為 n+2 秒。

```GO
// 背景執行
go func() {
	for {
		log.Println("休息")
		time.Sleep(1 * time.Second)
	}
}()

for {
	func() {
		log.Println("執行")
		time.Sleep(5 * time.Second)
	}()
	time.Sleep(2 * time.Second)
}
```

輸出如下，一個循環總共花了 7 秒。

```BASH
2020/12/11 00:08:12 休息
2020/12/11 00:08:12 執行 # 第一次
2020/12/11 00:08:13 休息
2020/12/11 00:08:14 休息
2020/12/11 00:08:15 休息
2020/12/11 00:08:16 休息
2020/12/11 00:08:17 休息
2020/12/11 00:08:18 休息
2020/12/11 00:08:19 執行 # 第二次
```

### 方法二

也可以使用 `time.Tick()` 方法疊代一個 `Ticker` 通道，來達到每隔一段時間執行程式的效果。此通道會以指定的週期回傳一個時間戳。如果期望的週期是 2 秒，程式的執行時間是 n 秒，則一次的循環最短為 2 秒，最長為 n 秒。

```GO
// 背景執行
go func() {
	for range time.Tick(time.Second) {
		log.Println("休息")
	}
}()

for range time.Tick(2 * time.Second) {
	func() {
		log.Println("執行")
		time.Sleep(5 * time.Second)
	}()
}
```

輸出如下，一個循環總共花了 5 秒。

```BASH
2020/12/11 00:10:01 休息
2020/12/11 00:10:02 執行 # 第一次
2020/12/11 00:10:02 休息
2020/12/11 00:10:03 休息
2020/12/11 00:10:04 休息
2020/12/11 00:10:05 休息
2020/12/11 00:10:06 休息
2020/12/11 00:10:07 休息
2020/12/11 00:10:07 執行 # 第二次
```

如果要立即執行程式的話，可以使用以下方法：

```GO
ticker := time.NewTicker(2 * time.Second)
for ; true; <-ticker.C {
	log.Println("執行")
	time.Sleep(5 * time.Second)
}
```

```BASH
2009/11/10 23:00:00 執行 # 第一次
2009/11/10 23:00:01 休息
2009/11/10 23:00:02 休息
2009/11/10 23:00:03 休息
2009/11/10 23:00:04 休息
2009/11/10 23:00:05 執行 # 第二次
```
